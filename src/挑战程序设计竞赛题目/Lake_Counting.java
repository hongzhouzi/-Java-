package 挑战程序设计竞赛题目;
/*
 有一个大小为N×M的园子，雨后积起了水。八连通的积水被认为是连接在一起的。请求出园子里总共有多少水洼？
 （八连通指的是下图中相对W 的*的部分）
			***
			*W*
			***
限制条件：N, M ≤ 100
输入
N=10, M=12
园子如下图（'W'表示积水，'.'表示没有积水）
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
输出
3  
  */
public class Lake_Counting {
	static int[][] field = {
        {1,0,0,0,0,0,0,0,0,1,1,0},
        {0,1,1,1,0,0,0,0,0,1,1,1},
        {0,0,0,0,1,1,0,0,0,1,1,0},
        {0,0,0,0,0,0,0,0,0,1,1,0},
        {0,0,0,0,0,0,0,0,0,1,0,0},
        {0,0,1,0,0,0,0,0,0,1,0,0},
        {0,1,0,1,0,0,0,0,0,1,1,0},
        {1,0,1,0,1,0,0,0,0,0,1,0},
        {0,1,0,1,0,0,0,0,0,0,1,0},
        {0,0,1,0,0,0,0,0,0,0,1,0} };
	static int N = 10;
	static int M = 12;
	static void dfs(int x,int y){
		field[x][y]=0;	//把当前这个位置标记一下，下次遇到时就不计算了
		//由当前这个位置向周围的八个方向试探
		for(int i=-1;i<=1;i++){
			for(int j=-1;j<=1;j++){
				int x1=x+i;
				int y1=y+j;
				if(x1>=0 && x1<N && y1>=0 && y1<M && field[x1][y1]==1)	//注意矩阵中的行与列范围
					//向四周试探时，不能超出矩阵的界限，四周如果有1，则向由该点转移，深度搜索
					dfs(x1,y1);
			}
		}
		return;
	}
	public static void main(String[] args) {
		int count=0;
		for(int i=0;i<N;i++){
			for(int j=0;j<M;j++){
				if(field[i][j]==1){
					dfs(i,j);
					count++;
				}
			}
		}
		System.out.println(count);
	}
}
